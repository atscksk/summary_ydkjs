# 1 스코프란 무엇인가
특정 장소에 변수를 저장하고 이후 그 변수를 찾는 것과 관련된 규칙

## 1.1 컴파일러 이론
자바스크립트는 컴파일러 언어  
컴파일레이션: 전통적 컴파일러 언어 처리 과정에서 프로그램을 이루는 소스 코드가 실행되기 전 거치는 3단계
### tokenizing / lexing
문자열을 나누어 '토큰'이라는 의미있는 조각으로 만드는 과정  
var a = 2;의 토큰
var, a, =, 2, ;
빈 칸의 경우 의미가 있는지에 따라 토큰이 될 수도 있음
### parsing
토큰 배열을 프로그램 문법 구조를 반영하여 중첩 원소를 갖는 트리 형태로 바꾸는 과정  
AST(Abstract Syntax Tree, 추상 구문 트리): 파싱 결과로 만들어진 트리  
var a = 2의 트리 - 변수 선언이라는 최상위 노드에서 시작, 'a'의 값을 가지는 확인자와 대입 수식이라는 자식 노드를 지님. 대입 수식 노드는 '2'라는 값을 지닌 숫자 리터럴을 자식 노드로 지님
### 코드 생성
AST를 컴퓨터에서 실행 코드로 바꾸는 과정  

자바스크립트 엔진은 세 가지 단계뿐 아니라 많은 부분에서 다른 프로그래밍 언어의 컴파일러보다 복잡  
자바스크립트 엔진은 자바스크립트 컴파일레이션을 미리 수행하지 않아서 최적화할 시간이 많지 않음

## 1.2 스코프 이해
### 1.2.1 처리 주체
프로그램을 처리하는 주체
- 엔진: 컴파일레이션의 시작부터 끝까지 전 과정과 자바스크립트 프로그램 실행을 책임
- 컴파일러: 파싱과 코드 생성 담당
- 스코프: 선언된 모든 확인자(변수) 검색 목록을 작성하고 유지. 또한 엄격한 규칙을 강제하여 현재 실행 코드에서 확인자의 적용 방식을 정함

### 1.2.2 앞과 뒤
프로그램 'var a = 2;' - 일반적으로 하나의 구문으로 여김  
엔진은 두 개의 서로 다른 구문으로 봄 - 컴파일러가 컴파일레이션 과정에서 처리할 구문, 실행 과정에서 엔진이 처리할 구문  
컴파일러 - 렉싱을 통해 구문을 토큰으로 쪼갬. 그 후 토큰을 파싱하여 트리 구조 생성  

"변수를 위해 메모리를 할당하고 할당된 메모리를 a라 명명한 후 그 변수에 2를 넣는다"  
컴파일러는 위와 같은 예상과는 다른 방식으로 일을 처리  
1. 컴파일러가 'var a'를 만나면 스코프에게 변수 a가 특정한 스코프 컬렉션 안에 있는지 물음. 변수 a가 이미 있다면 컴파일러는 선언을 무시하고 지나가고, 그렇지 않으면 컴파일러는 새로운 변수 a를 스코프 컬렉션 내에 선언하라고 요청함
2. 그 후 컴파일러는 'a = 2' 대입문 처리를 위해 나중에 엔진이 실행할 수 있는 코드를 생성. 엔진이 실행하는 코드는 먼저 스코프에게 a라 부르는 변수가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인. 가능하다면 엔진은 변수 a를 사용, 아니라면 엔진은 다른 곳을 탐색  

별개의 두 가지 동작을 통해 변수 대입문을 처리  
- 컴파일러가 변수를 선언(현재 스코프에 미리 변수가 선언되지 않은 경우)
- 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대임

### 1.2.3 컴파일러체
컴파일러가 생성한 코드를 실행할 때 엔진은 변수 a가 선언된 적이 있는지 스코프에서 검색  
어떤 종류의 검색을 하느냐에 따라 검색 결과가 달라짐  
위의 예시에서는 엔진은 변수 a를 찾기 위해 LHS 검색을 수행(다른 종류의 검색은 RHS)  
LHS와 RHS는 대입 연산 방향의 차이  
LHS 검색: 변수가 대입 연산자의 왼쪽에 있을 때 수행  
RHS 검색: 변수가 대입 연산자의 오른쪽에 있을 때 수행  
RHS 검색은 단순히 특정 변수의 값을 찾는 것과 동일. LHS 검색은 값을 넣어야 하므로 변수 컨테이너 자체를 탐색  
RHS는 그 자체로 '대입문의 오른쪽'이 아니라 '왼편이 아닌 쪽'에 가까움
```javascript
console.log(a);
```
a에 대한 참조는 RHS 참조 - 구문에서 a에 아무것도 대입하지 않기 때문  

```javascript
a = 2;
```
a에 대한 참조는 LHS 참조. 현재의 a 값을 신경쓸 필요 없이 '= 2' 대입 연산 수행 대상 변수를 찾기 때문

LHS와 RHS 참조를 모두 수행하는 경우
```javascript
function foo(a) {
  console.log(a);
}
foo(2);
```
함수 호출 시 RHS 참조 사용  
인수로 값 2를 함수 foo()에 넘겨줄 때 값 2를 인자 a에 대입하는 연산 발생  
인자 a에 대한 대입 연산을 위해 LHS 검색이 수행됨  
변수 a에 대한 RHS 참조 역시 수행 - 결과값이 console.log() 함수에 전달, console.log()가 실행되기 위해 참조가 필요  
-> console 객체를 RHS 검색하여 log 메서드가 있는지 확인  
구현된 log() 내부 인자 존재 -> 첫 번째 인자를 LHS 검색으로 찾아 2를 대입

### 1.2.4 엔진과 스코프의 대화
```javascript
function foo(a) {
  console.log(a);
}
foo(2);
```
p.199 엔진과 스코프의 대화 해석  
엔진: foo에 대한 RHS 참조를 위해 스코프에 foo 탐색 요청  
스코프: 컴파일러 선언 내역을 확인하고 foo 탐색, 엔진에 전달  
엔진: foo 실행  
엔진: a에 대한 LMS 참조를 위한 a 탐색 요청  
스코프: 컴파일러 선언 내역을 확인하고 a를 탐색, 엔진에 전달  
엔진: a에 2를 대입  
엔진: console에 대한 RHS 참조를 위해 스코프에 console 탐색 요청  
스코프: 내장 객체 목록 중에서 console 탐색. 엔진에 전달  
엔진: log()에 대한 탐색 요청  
스코프: log() 탐색 및 엔진에 전달  
엔진: a의 값을 확인하고 log()에 인자로 넘김  

### 1.2.5 퀴즈
```javascript
function foo(a) {
  var b = a;
  return a + b;
}
var c = foo(2);
```
1. 모든 LHS 검색을 찾아보라
2. 모든 RHS 검색을 찾아보라

## 1.3 중첩 스코프
여러 개의 스코프를 고려해야 하는 상황  
엔진은 대상 변수를 현재 스코프에서 발견하지 못하면 다음 바깥 스코프로 넘어가거나 글로벌 스코프에서 변수를 탐색
```javascript
function foo(a) {
  console.log(a + b);
}
var b = 2;
foo(2);
```
b에 대한 RHS 참조는 foo 함수 안에서 처리 불가 -> 함수를 포함하는 스코프에서 처리  
중첩 스코프 탐사의 규칙
- 엔진은 현재 스코프에서 변수를 찾기 시작하고, 찾지 못하면 한 단계씩 올라감
- 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색을 중단

## 1.4 오류
LHS와 RHS 검색 방식은 변수가 아직 선언되지 않았을 때 서로 다르게 동작
```javascript
function foo(a) {
  console.log(a + b);
  b = a;
}
foo(2);
```
b에 대한 첫 RHS 검색 실패 시 다시 b를 찾을 수 없음 - 스코프에서 찾지 못한 변수는 '선언되지 않은 변수'  
RHS 검색이 중첩 스코프 내 어디에서도 변수를 찾지 못하면 엔진은 'ReferenceError' 발생  

LHS 검색을 수행하여 변수를 찾지 못하고 글로벌 스코프에 도달할 때 프로그램이 'Strict Mode'로 동작하고 있는 것이 아니라면, 글로벌 스코프는 엔진이 검색하는 이름을 가진 새로운 변수를 생성하여 엔진에 전달  

Strict Mode에서는 글로벌 변수를 자동 또는 암시적으로 생성 불가 - LHS 검색 시에도 RHS와 마찬가지로 ReferenceError를 발생시킴  

RHS 검색 결과 변수는 찾았지만 그 값을 통해 불가능한 일을 하려고 할 경우 - 함수가 아닌 값을 함수처럼 실행하거나 null이나 undefined 값을 참조  
-> 엔진은 TypeError를 발생시킴  
=> ReferenceError는 스코프에서 대상을 찾았는지와 관계, TypeError는 스코프 검색은 성공했으나 결과값을 통해 적합하지 않거나 불가능한 시도를 한 경우를 의미