# ch2 렉시컬 스코프
스코프의 두 가지 작동 방식
- 렉시컬 스코프: 일반적이고 다수의 프로그래밍 언어가 사용하는 방식
- 동적 스코프: bash scripting이나 perl의 일부 모드에서 사용

## 2.1 렉스타임
렉싱 처리과정에서 소스코드 문자열을 분석하여 상태 유지 파싱의 결과로 생성된 토큰에 의미를 부여함  
렉시컬 스코프는 렉싱 타임에 정의되는 스코프  
렉시컬 스코프는 프로그래머가 코드를 짤 때 변수와 스코프 블록을 어디에 작성하는가에 기초해서 렉서가 코드를 처리할 때 확정됨  
```javascript
// ------------1
function foo(a) { // ----------2
  var b = a * 2;
  function bar(c) { // ----3
    console.log(a, b, c); 
  }
  bar(b * 3);
}
foo(2);
```
3개의 중첩 스코프, 스코프를 겹쳐진 버블이라고 가정    
1. 글로벌 스코프를 감싸고 있고, 해당 스코프 안에는 하나의 확인자(foo)가 있음
2. foo의 스코프를 감싸고 있고, 해당 스코프는 3개의 확인자(a, bar, b)를 포함
3. bar 스코프를 감싸고 있고, 해당 스코프는 하나의 확인자(d) 포함  

bar의 버블의 foo의 버블 내보에 완전히 포함 - foo 내부에서 bar 함수를 정의했기 때문  
중첩 버블의 경계 - 버블 간 경계가 교차할 수 없음  
어떤 함수의 버블이 동시에 다른 두 스코프 버블 안에 존재할 수 없음  

### 2.1.1 검색
엔진은 스코프 버블의 구조와 상대적 위치를 통해 확인자의 위치 탐색  
엔진은 console.log() 구문 실행 후 3개의 참조된 변수 a, b, c를 검색  
검색은 가장 안쪽 스코프 버블인 bar() 함수 스코프에서 시작  
a를 찾지 못하면 다음 가까운 스코프 버블인 foo()로 이동, 이곳에서 a를 찾아 사용  
변수 c가 bar()와 foo() 내부에 모두 존재한다고 가정, console.log() 구문은 bar() 내부에 있는 c를 찾아서 사용, foo()에서 c 탐색을 시도하지 않음  
스코프는 목표와 일치하는 대상을 찾는 즉시 검색을 중단함  
섀도잉: 여러 중첩 스코프 층에 걸쳐 같은 확인자 이름을 정의 가능. 더 안쪽의 확인자가 더 바깥쪽의 확인자를 가리는 것  
어떤 함수가 어디서 또는 어떻게 호출되는지에 상관없이 함수의 렉시컬 스코프는 함수가 선언된 위치에 따라 정의됨  

렉시컬 스코프 검색 과정은 a, b, c와 같이 일차 확인자 검색에만 적용됨 - 코드에서 foo.bar.baz의 참조를 찾는다고 하면 렉시컬 스코프 검색은 foo 확인자를 찾는 데 사용되지만, 일단 foo를 찾고 나서는 객체 속성 접근 규칙을 통해 bar와 baz의 속성을 각각 가져옴

## 2.2 렉시컬 속이기
두 가지 방법이 있으나 모드 권장되지 않음  

### 2.2.1 eval
eval(): 문자열을 인자로 받아들여 실행 시점에 문자열의 내용을 코드의 일부분처럼 처리
```javascript
function foo(str, a) {
  eval(str);
  console.log(a, b);
}
var b = 2;
foo("var b = 3;", 1);
```
문자열 "var b = 3;"은 eval() 호출 시점에 원래 있던 코드인 것처럼 처리됨  
새로운 변수 b를 선언하면서 이미 존재하는 foo()의 렉시컬 스코프를 수정  
foo()안에 변수 b를 생성하여 바깥 스코프에 선언된 변수 b를 가림  
console.log()가 호출될 때 a, b 모두 foo() 스코프에서 찾을 수 있으므로 바깥의 b는 탐색 시도하지 않음

strict mode에서 eval() 사용 시 eval()은 자체적인 렉시컬 스코프를 이용함. 즉, eval() 내에서 실행된 선언문은 현재 위치의 스코프를 실제로 수정하지 않음
```javascript
function foo(str) {
  "use strict";
  eval(str);
  console.log(a);
}
foo("var a = 2");
```

eval()과 비슷한 효과를 내는 다른 방법 - setTimeout()과 setInterval()의 첫 번째 인자로 문자열 투입, 문자열의 내용은 동적 생성된 함수 코드처럼 처리됨 -> 구식 빙법, 없어질 예정. 사용 권장되지 않음  
new Function() - 문자열을 마지막 인자로 받아서 동적으로 생성된 함수로 바꿈. eval()보다 안전하지만 마찬가지로 권장되지 않음  
동적 생성 코드는 성능 저하를 감수할 만큼 활용도가 높지는 않음

### 2.2.2 with
없어질 예정인 기능이며 사용이 권장되지 않음  
일반적으로 한 객체의 여러 속성을 참조할 때 객체 참조를 매번 반복하지 않기 위해 사용  
```javascript
var obj = {
  a: 1,
  b: 2,
  c: 3
}

obj.a = 2;
obj.b = 3;
obj.c = 4;

with (obj) {
  a = 3;
  b = 4;
  c = 5;
}
console.log(obj);
```
단순히 객체 속성을 편하게 접근할 수 있는 특성 이상의 효과
```javascript
function foo(obj) {
  with (obj) {
    a = 2;
  }
}

var o1 = {
  a: 3
}

var o2 = {
  b: 3
}

foo(o1);
console.log(o1.a);

foo(o2);
console.log(o2.a);

console.log(a);
```
대입문 "a = 2"가 글로벌 변수 a를 생성  
with 문은 속성을 가진 객체를 받아 하나의 독릭된 렉시컬 스코프처럼 취급  
따라서 객체의 속성은 모두 해당 스코프 안에 정의된 확인자로 간주  
with 블록 안에서 일반적인 var 선언문이 수행될 경우 선언된 변수는 with 블록이 아니라 with를 포함하는 함수의 스코프에 속함  

eval()은 인자로 받은 코드 문자열에 하나 이상의 선언문이 있을 경우 이미 존재하는 렉시컬 스코프를 수정할 수 있으나, with문은 넘겨진 객체를 가지고 사실상 하나의 새로운 렉시컬 스코프를 생성함

o1을 넘겨받은 with문은 o1이라는 스코프를 선언하고, 그 스코프는 o1.a속성에 해당하는 확인자를 가짐. 그러나 o2가 스코프로 사용되면 그 스코프에는 a 확인자가 없으므로 이후 작업은 일반적인 LHS 확인자 검색 규칙에 따라 진행됨  
o2 스코프, foo() 스코프, 글로벌 스코프에서도 a 확인자를 찾을 수 없으므로 "a = 2가 수행되면 자동으로 그에 해당하는 글로벌 변수가 생성됨  

### 2.2.3 성능
컴파일레이션 단계에서 자바스크립트 엔진은 최적화 작업을 진행  
렉싱된 코드를 분석하여 모든 변수와 함수 선언문이 어디에 있는지 파악하고 실행 과정에서 확인자 검색을 더 빠르게 하는 것  
그러나 with나 eval()이 있다면 엔진이 미리 확인해둔 확인자의 위치가 틀릴 수도 있다고 가정해야 함  
렉싱 타임일 때 eval()에 어떤 코드가 전달되어 렉시컬 스코프가 수정될지 정확히 알 수 없고, with에 넘긴 객체의 내용에 따라 새로운 렉시컬 스코프가 생성될 수 있기 때문  
eval()이나 with가 있다면 대다수 최적화가 의미가 없어서 결과적으로 최적화를 하지 않은 것이나 마찬가지가 됨